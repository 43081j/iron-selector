<!--
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<script>

  /**
  FIXME(ffu): should probably move it to its own repo.
  `core-selectable` is a mixin that can be used to manage a list of elements
  that can be selected.
  FIXME(ffu): currently the element must bind the `selected` property to `_selectedChanged`, e.g.

      bind: {
        selected: '_selectedChanged'
      },

  @group Polymer Mixins
  @element core-selectable
  @homepage github.io
  */
  modulate('core-selectable', function() {
    return {

      /* The class to set on elements when selected */
      selectedClass: 'core-selected',

      /* The attribute to set on elements when selected */
      /* selectedAttribute: 'active', */

      /* If you want to use the attribute value of an element for `selected` instead of
      using the index, set `attrForSelected` to the name of the attribute. */
      /* attrForSelected: 'name', */

      excludedLocalNames: {
        'template': 1
      },

      /* `selected` property change handler */
      _selectedChanged: function(selected) {
        this.updateItem(this.valueToItem(this.selected));
      },

      updateItem: function(item) {
        this.applySelection(item, true);
        this.applySelection(this.item, false);
        this._setItem(item);
      },

      valueToItem: function(value) {
        return (value == null) ? null : this.items[this.valueToIndex(value)];
      },

      valueToIndex: function(value) {
        if (this.attrForSelected) {
          for (var i = 0, item; item = this.items[i]; i++) {
            if (this.valueForItem(item) == value) {
              return i;
            }
          }
        } else {
          return value;
        }
      },

      indexToValue: function(index) {
        if (this.attrForSelected) {
          var item = this.items[index];
          if (item) {
            return this.valueForItem(item);
          }
        } else {
          return index;
        }
      },

      valueForItem: function(item) {
        return item[this.attrForSelected] || item.getAttribute(this.attrForSelected);
      },

      // if `item` is published and readOnly, this will be overridden by the generated _setItem
      _setItem: function(item) {
        this.item = item;
      },

      applySelection: function(item, isSelected) {
        if (!item) {
          return;
        }
        if (this.selectedClass) {
          this.toggleClass(this.selectedClass, isSelected, item);
        }
        if (this.selectedAttribute) {
          this.toggleAttribute(this.selectedAttribute, isSelected, item);
        }
      },

      /**
       * Returns an array of selectable items.
       *
       * @property items
       * @type Array
       */
      get items() {
        if (!this.itemFilter) {
          this.itemFilter = this.filterItem.bind(this);
        }
        var t = this.target || this;
        var nodes = this.selectable ? t.querySelectorAllComposed(this.selectable) :
            t.childrenComposed();
        return Array.prototype.filter.call(nodes, this.itemFilter);
      },

      childrenComposed: function() {
        var nodes = [];
        Array.prototype.forEach.call(this.children, function(n) {
          if (n instanceof HTMLContentElement) {
            nodes = nodes.concat(this.lightDom.distributedNodes(n));
          } else {
            nodes.push(n);
          }
        }, this);
        return nodes;
      },

      filterItem: function(node) {
        return node != this && node.localName && !this.excludedLocalNames[node.localName];
      },

      observeItems: function() {
        if (this._observer) {
          this._observer.disconnect();
        }
        this._observer = new MutationObserver(this.effectSelected.bind(this));
        this._observer.observe(this.target, {
          childList: true,
          subtree: true
        });
      },

      effectSelected: function() {
        if (this.selected != null) {
          this._selectedEffector();
        }
      },

      /**
       * Selects the previous item.
       *
       * @method selectPrevious
       */
      selectPrevious: function() {
        var length = this.items.length;
        this.selected = (Number(this.valueToIndex(this.selected)) - 1 + length) % length;
      },

      /**
       * Selects the next item.
       *
       * @method selectNext
       */
      selectNext: function() {
        this.selected = (Number(this.valueToIndex(this.selected)) + 1) % this.items.length;
      }

    };
  });

</script>
