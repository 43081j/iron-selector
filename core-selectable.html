<!--
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<script>

  /**
  FIXME(ffu): should probably move it to its own repo.
  `core-selectable` is a mixin that can be used to manage a list of elements
  that can be selected.
  FIXME(ffu): currently the element must bind the `selected` property to `selectedChanged`, e.g.

      bind: {
        selected: 'selectedChanged'
      },

  @group Polymer Mixins
  @element core-selectable
  @homepage github.io
  */
  modulate('core-selectable', function() {
    return {

      /* The class to set on elements when selected */
      selectedClass: 'core-selected',

      /* The attribute to set on elements when selected */
      selectedAttribute: '',

      excludedLocalNames: {
        'template': 1
      },

      /* `selected` property change handler */
      selectedChanged: function(selected) {
        this.updateItem(this.items[selected]);
      },

      updateItem: function(item) {
        if (this.selectedAttribute) {
          this.attributeFollows(this.selectedAttribute, item, this.item);
        }
        if (this.selectedClass) {
          this.classFollows(this.selectedClass, item, this.item);
        }
        this._setItem(item);
      },

      // if `item` is published and readOnly, this will be overridden by the generated _setItem
      _setItem: function(item) {
        this.item = item;
      },

      /**
       * Returns an array of selectable items.
       *
       * @property items
       * @type Array
       */
      get items() {
        var t = this.target || this;
        var nodes = this.selectable ? t.querySelectorAll(this.selectable) : t.children;
        return Array.prototype.filter.call(nodes, this.filterItem.bind(this));
      },

      filterItem: function(node) {
        return node != this && node.localName && !this.excludedLocalNames[node.localName];
      },

      observeItems: function() {
        if (this._observer) {
          this._observer.disconnect();
        }
        this._observer = new MutationObserver(this.updateSelected.bind(this));
        this._observer.observe(this.target, {
          childList: true,
          subtree: true
        });
      },

      updateSelected: function() {
        if (this.selected >= 0) {
          this._selectedEffector();
        }
      },

      /**
       * Selects the previous item.
       *
       * @method selectPrevious
       */
      selectPrevious: function() {
        this.selected =
          (Number(this.index) - 1 + this.items.length) % this.items.length;
      },

      /**
       * Selects the next item.
       *
       * @method selectNext
       */
      selectNext: function() {
        this.selected = (Number(this.index) + 1) % this.items.length;
      }

    };
  });

</script>
